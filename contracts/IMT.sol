// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "./MiMC5Sponge.sol";

contract IMT is MiMC5Sponge {
    uint32 constant public levels = 32;
    uint32 constant public maxLeaves = 2**levels - 1;
    uint256[levels] public zeroRoots = [
        0,
        6582740095095376936388179666706376640995777958302529689294846430676159692127,
        8594721407560365127130622972175500268616495828059219379003256900450185710810,
        6667261598277140271578964885652772869648918265146277420458780204710400325257,
        5183094187280101864874049098952936045481730985445714173635767183873944143021,
        12441557953856452793645357865592341042941605090207686399486882868915022936141,
        163019367813157124981986468775632397932983619624170746035315166781740651022,
        18688234030344309017258228155084759039905994670031808918473712913845874948037,
        20478777889054631103525695978664168911310218501976985113414162845378436393163,
        16980796853036778270597387329820875545103363566724874358286130213492976147367,
        19501156449656361740362811270696481855743072923075404738140535885551140375129,
        18311433763442562696037285505277986550927101968394921864552597385161504450587,
        9511938779113839454803514361909168087476415667206336930444944274765938630695,
        13888272932959988111652429174317856142605235832112819806465012447591462227812,
        18134897707718276278645464684138296007196249036169174926643704164345662406440,
        7557859747360474710096083215248720479245006712931969862846177619425808294124,
        12115863757084662063908369433171022262731473467407285524517152459320624006397,
        11280310429620511099107213095596545365053967092760303952389282704344031255267,
        4830326914424446341063839249256918977319982071996541621864132183971740740670,
        9938476896192695687979736455027545960664015596017573903072507180577818462009,
        18312229310512897340944588726144933464974926778432302637649525746676852135974,
        10979949702503599018305915672587140717388918852422361981983686892353045227767,
        15066004830038430011036701957632015189383504714861587120236631685021590903532,
        15764268234290892482394591758751960456242539597787859457173901178236788290856,
        14858080689706237210266151236110184759037473761883681688431562214073274400167,
        4896863994131692334051585855708851867672801650116655506621135611230071015951,
        4931912836419305284602917914395167115749056150299637895338125525182355137526,
        4387456119243961886803365529020640704380314826234939598275631780180332366597,
        19479291821562414416560513638835061088092785999503363877733786194506052248269,
        4120788972136264636026863597572653381958602868401631073217535238343304722269,
        7646770362641118070369799216014043367822570482264277793761363988655232463386,
        1381856975271698469635121971255866350151543293024017282402342615054531244757
    ];
    uint32 public currentLeafIndex = 0;
    mapping(uint32 => mapping(uint32 => uint256)) private tree;
    mapping(uint32 => mapping(uint32 => bool)) private isTreeSet;
    
    function getTreeNode(uint32 _level, uint32 _index) public view returns (uint256) {
        if(isTreeSet[_level][_index]) return tree[_level][_index];
        return zeroRoots[_level];
    }
    
    function setTreeNode(uint32 _level, uint32 _index, uint256 _value) private {
        tree[_level][_index] = _value;
        isTreeSet[_level][_index] = true;
    }
    
    function insertLeaf(uint256 _leaf) public {
        require(currentLeafIndex <= maxLeaves, "Tree is full");
        setTreeNode(0, currentLeafIndex, _leaf);
        // Update the path till the root
        uint256 currIdx = currentLeafIndex;
        for(uint32 i = 1; i < levels; i++) {
            uint256 left;
            uint256 right;
            if(currentLeafIndex % 2 == 0) {
                left = getTreeNode(i - 1, currentLeafIndex);
                right = getTreeNode(i - 1, currentLeafIndex + 1);
            } else {
                left = getTreeNode(i - 1, currentLeafIndex - 1);
                right = getTreeNode(i - 1, currentLeafIndex);
            }
            uint256 parent = miMCSponge(left, right);
            setTreeNode(i, currIdx / 2, parent);
            currIdx /= 2;
        }
        currentLeafIndex++;
    }
}